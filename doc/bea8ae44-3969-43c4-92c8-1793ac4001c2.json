{
    "summary": "This Lua library offers efficient, memory-efficient combination and permutation functions through iterators, with 'permute', 'powerset', and 'shuffle' functions provided. Performance tests in Lua 5.1 and LuaJIT are included, and it is licensed under MIT.",
    "details": [
        {
            "comment": "Pure, performant Lua library for combination and permutation tasks, utilizing iterators for memory efficiency and better LuaJIT optimization. Functions operate on Lua arrays, returning multiple results instead of tables to reduce expensive table operations. Minimizing resource usage and object creation within each function is prioritized.",
            "location": "\"/media/root/Prima/works/generated_docs/lazer_doc/src/multilingual/rockstar/newdawn/info_gather/luacombine/README.md\":0-30",
            "content": "# luacombine\nPure, performant combination and permutation library for Lua and LuaJIT.\n# Installation\n    luarocks install --server=http://luarocks.org/dev luacombine\n# Documentation\nAll functions operate on Lua arrays. E.g.\n    {1,2,3}\n    {'a','b','c','d'}\n    {{'a'},{1,2},{a=4,b=9},7}\n    etc...\nAll functions return an iterator which returns multiple results (instead of tables).\nIterators were used because they are more memory efficient and because they are well optimised\nfor by LuaJIT. Multiple results are returned instead of tables because creating tables is an\nexpensive operation in Lua. Returning multiple results allows the decision to create a table\nto be passed onwards so that it's only done when it's required. Further, making a table from\nmultiple results (e.g. local x = {f()}) is more efficient in Lua than making a table by\nincrementally adding to it.\nGenerally inside of each function, I've tried to use as few resources as possible and\nto minimise object creation.\n## Including in a project\n    C = require 'luacombine'"
        },
        {
            "comment": "This code defines three functions: combn, combn_many, and permute. All of them produce combinations or permutations of elements in a given table and output an iterator which returns a new combination for every call, except the last one which returns nil. Examples are provided to illustrate their usage.",
            "location": "\"/media/root/Prima/works/generated_docs/lazer_doc/src/multilingual/rockstar/newdawn/info_gather/luacombine/README.md\":32-72",
            "content": "## combn(tbl,n) -> iterator\nProduce all combinations of *n* elements from array *tbl*. It outputs an iterator which\nreturns a new combination for every call, except for the last call which returns a nil.\nExample:\n    for a,b in C.combn({'x','y','z'}, 2) do ... end\n    -- or ...\n    local f = C.combn({'x','y','z'}, 2)\n    while true do\n        local x = {f()}\n        if #x == 0 then break end\n        ...\n    end\n## combn_many(...) -> iterator\nProduces all of the combination of drawing one element for each list provided. It outputs\nan iterator which returns a new combination for every call, except for the last call which\nreturns a nil.\nExample:\n    for a,b in C.combn_many({'x','y','z'}, {1,2,3}) do ... end\n    -- or\n    local f = C.combn_many({'x','y','z'}, {1,2,3})\n    while true do\n        local x = {f()}\n        if #x == 0 then break end\n        ...\n    end\n## permute(tbl) -> iterator\nProduces all of the permutations of the elements in *tbl*. It outputs an iterator which\nreturns a new combination for every call, except for the last call which returns a nil."
        },
        {
            "comment": "This code defines three functions: 'permute', 'powerset', and 'shuffle'. The 'permute' function generates all permutations of elements in a table, the 'powerset' function produces all subsets of elements in a table, and the 'shuffle' function rearranges the order of array elements using the Fisher-Yates algorithm. The code also mentions a basic test suite for verifying the functions' outputs.",
            "location": "\"/media/root/Prima/works/generated_docs/lazer_doc/src/multilingual/rockstar/newdawn/info_gather/luacombine/README.md\":74-121",
            "content": "Example:\n    for a,b,c in C.permute({'x','y','z'}) do ... end\n    -- or\n    local f = C.permute({'x','y','z'})\n    while true do\n        local x = {f()}\n        if #x == 0 then break end\n        ...\n    end\n## powerset(tbl) -> iterator\nProduces all of the subsets of the elements in *tbl*. It outputs an iterator which\nreturns a new combination for every call, except for the last call which returns a nil.\nExample:\n    for a,b,c in C.powerset({'x','y','z'}) do ... end\n    -- or\n    local f = C.powerset({'x','y','z'})\n    while true do\n        local x = {f()}\n        if #x == 0 then break end\n        ...\n    end\n## shuffle(tbl) -> tbl\nReshuffles the order of an array in a table using the Fisher-Yates algorithm. It does not\nset the random seed. So use *math.randomseed(<value>)* if you'd like to set it. Note that this\nfunction mutates it's parameter.\nExample:\n    x = {'x','y','z'}\n    C.shuffle(x)\n# Test suite\nThere is a basic test suite at the moment which verifies that the number of items returned\nis as expected. To run it:"
        },
        {
            "comment": "This code displays the elapsed time for various performance tests executed with both vanilla Lua 5.1 and LuaJIT, highlighting the difference in efficiency between them. It also provides information on the potential number of combinations and permutations generated by specific functions at certain array sizes. The code is licensed under MIT.",
            "location": "\"/media/root/Prima/works/generated_docs/lazer_doc/src/multilingual/rockstar/newdawn/info_gather/luacombine/README.md\":123-161",
            "content": "    lua test.impl.lua\n# Performance\nRun the performance tests:\n    lua perf.impl.lua\n    or\n    luajit perf.impl.lua\nWith vanilla Lua 5.1:\n| Description | Elapsed |\n| --- | --- |\n| combn, array size #500, pick 3 | 4.740285s |\n| combn_many,3 arrays #200 | 3.596942s |\n| powerset, array size #20 | 5.3622s |\n| permute, array size #10 | 3.753631s |\nWith LuaJIT:\n| Description | Elapsed |\n| --- | --- |\n| combn, array size #500, pick 3 | 1.128s |\n| combn_many,3 arrays #200 | 0.846391s | \n| powerset, array size #20 | 3.077064s |\n| permute, array size #10 | 0.830082s |\nNB: **combn({...},3)** with an array of size 500 would produce 20708500 combinations\nof length 3. **powerset({...})** with an array of size 20 would produce 1048576\npermutations of length 20.\n# License\nMIT Licensed, please see LICENSE file for more information."
        }
    ]
}